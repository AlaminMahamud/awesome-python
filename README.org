#+TITLE: My Awesome Python Handbook
#+AUTHOR: Muhammad Alamin Khan
#+EMAIL: alamin.ineedahelp@gmail.com
#+STARTUP: overview indent inlineimages hideblocks
#+DESCRIPTION: Quick Reference for this ever-forgetting mind.

Notes that I tend to forget all the time and search on the internet

* CHEATSHEET
** architecture
[[./images/architecture/001.jpg]]
- *Parser* - source code ⇒ abstract syntax tree [AST].
- *compiler* - AST ⇒ Python Byte Code.
- *interpreter* - execute line by line
*More* - [[./architecture.org][architecture.org]]
** components
functions ⇒ classes ⇒ modules ⇒ packages
** file extensions
- py ⇒ The normal extension for a Python source file
- pyc ⇒ The compiled bytecode
- pyd ⇒ A Windows DLL file
- pyo ⇒ A file created with optimizations
- pyw ⇒ Python script for Windows
- pyz ⇒ Python script archive
** pros and cons
*** pros
- extensive libs
- embeddable
- iot
- readable
- free and open source
- extensible
- improved productivity
- simple and easy
- oop
- portable
*** cons
- speed limitations
- weak in mobile computing and browsers
- design restrictions
- underdeveloped Database Access Layers
- simple
** rules
#+BEGIN_SRC python
"""
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
"""
#+END_SRC

** variable types
| Variable Type | Description                            | Casting | Examples                |
|---------------+----------------------------------------+---------+-------------------------|
| int           | whole number                           | int()   | 5, -11, 0               |
| float         | float number                           | float() | 9.57, -0.256, 1.0       |
| string        | ordered, immutable character container | str()   | "this is a string"      |
| bool          | bolean                                 | bool()  | true, false             |
| list          | ordered, mutable container             | list()  | [1, 2.0, "hi"]          |
| dictionary    | unordered, mutable, associative array  | dict()  | {"k1": "v1", "k2":"v2"  |
| tuple         | ordered, immutable                     | tuple() | (4, 9), ("word1", "w2") |
| set           | immutable, ordered                     | set()   | {1, 2, 3, "hello"}      |
|---------------+----------------------------------------+---------+-------------------------|
*** Numbers
- Real Numbers
- Complex Numbers
#+BEGIN_SRC python
a = 2 + 3j
#+END_SRC
- binary, octal, hexadecimal
#+BEGIN_SRC python
'''
binary  => 0b or 0B
octal   => 0o or 0O
hexadec => 0x or 0X
'''
#+END_SRC
- decimal module
- fractions module
- math module
** variable scope
*** Different scopes:
[[https://data-flair.training/blogs/wp-content/uploads/Scopes-01.jpg]]
- local
#+BEGIN_SRC python
  >>> a=0
  >>> def func():
        print(a)
        a=1
        print(a)            
  >>> func()
  Traceback (most recent call last):
  File "<pyshell#79>", line 1, in <module>
  func()
  File "<pyshell#78>", line 2, in func
  print(a)
  UnboundLocalError: Local Variable 'a' referenced before assignment.
#+END_SRC
- enclosing
#+BEGIN_SRC python
  def red():
      a = 1
    
      def blue():
          b = 2
          print(a)
          print(b)

      blue()
      print(a)

  red()

"""
1
2
1
"""
#+END_SRC
- nonlocal <keyword>
#+BEGIN_SRC python
  # without nonlocal
  x = 0
  def outer():
      x = 1
      def inner():
          x = 2
          print("inner:", x)

      inner()
      print("outer:", x)

  outer()
  print("global:", x)

  # inner: 2
  # outer: 1
  # global: 0
#+END_SRC
#+BEGIN_SRC python
"""
To this, using nonlocal, where inner()'s x is now also outer()'s x:
"""
x = 0
def outer():
    x = 1
    def inner():
        nonlocal x
        x = 2
        print("inner:", x)

    inner()
    print("outer:", x)

outer()
print("global:", x)

# inner: 2
# outer: 2
# global: 0
#+END_SRC
#+BEGIN_SRC python
"""
If we were to use global, it would bind x to the properly "global" value:
"""
x = 0
def outer():
    x = 1
    def inner():
        global x
        x = 2
        print("inner:", x)

    inner()
    print("outer:", x)

outer()
print("global:", x)

# inner: 2
# outer: 1
# global: 2
#+END_SRC
- global
#+BEGIN_SRC python
  a = 1
  def counter():
      global a
      a = 2
      print(a)
  counter()
  """
  a becomes 2 both inside and outside
  """
#+END_SRC
- built-in
#+BEGIN_SRC python
"""
we never need to import any modules to access built-ins like print(), id()
"""
#+END_SRC
** operators
#+BEGIN_SRC python
5 +  5   # + => addition
6 -  2   # - => subtraction
1 *  2   # * => multiplication
5 /  2   # / => division with floating point ## output:: 2.5
5 // 2   # // => division without integer flooring the float value ## output :: 2
2 ** 3   # exponent
5 %  2   # modulus
5 >  2   # greater than op
5 <  2   # less than op
5 >= 2   # greater than equal
5 <= 2   # lesser than equal
5 == 5   # returns true if equal else false
5 is 5   # returns true if equal else false
10 != 5  # returns true if not equal
10 is not 5 # returns true if not equal
1 in [3, 4, 5, 6] # returns true if 1 is in the collection
#+END_SRC

** strings
*** create a string
#+BEGIN_SRC python
>>> type('Hello World')
<class 'str'>
#+END_SRC

python doesn't have the char data-type
#+BEGIN_SRC python
a='Hello"
# outputs
# SyntaxError: EOL while scanning string literal
#+END_SRC

a string is immutable; it can't be changed
#+BEGIN_SRC python
>>> a="Dogs"
>>> a[0]="H"
Traceback (most recent call last):
File "<pyshell#22>", line 1, in <module>
a[0]="H"

"""
TypeError: 'str' object doesn't support item assignment
"""
#+END_SRC

*** string slicing
#+BEGIN_SRC python
a = 'Hello There'
# displaying a single character
a[1]

# slicing a string
"""
a[start:end:step] # start through not past end, by step
a[start:end]      # items start through end-1
a[start:]         # items start through the rest of the array
a[:end]           # items from the beginning through end-1
a[:]              # copy of whole array
"""
#+END_SRC
*** string concatenation
#+BEGIN_SRC python
a = 'Do you see this,'
b = '$$'
a + b # => 'Do you see this, $$
2 * a # => Do you see this,Do you see this,
a * 2 # => Do you see this,Do you see this,

>>> '10'+10
Traceback (most recent call last):
File "<pyshell#49>", line 1, in <module>
#+END_SRC
*** string formatters
#+BEGIN_SRC python
"""
f-strings
"""
name='John D. Rockerfeller'
print(f"Happy birthday, {name} Sir")
#+END_SRC

#+BEGIN_SRC python
"""
format() method
"""
a="cats"
print("I love {0}".format(a))
print("I love {0}".format(a="Dogs"))

"""
The variables don’t have to defined before the print statement
"""
print("I love {b}".format(b='ferrets'))

"""
% operator- The % operator goes where the variables go in a string. 
%s is for string. What follows the string is the operator and variables in parentheses/in a tuple.
%d -> int
%f -> float
"""
print("I love %s and %s" %(a,b))
#+END_SRC

** lists
#+BEGIN_SRC python
  # create a list
  bikes = ['trek', 
	   'redline',
	   'giant']

  # list index structure
  """
   +---+---+---+---+---+---+
   | P | y | t | h | o | n |
   +---+---+---+---+---+---+
     0   1   2   3   4   5   
    -6  -5  -4  -3  -2  -1
  """
  # first item
  bikes[0]
  # last item
  bikes[-1]

  # looping through a list
  for bike in bikes:
      print(bike)


  bikes = []
  # Adding items to a list at the end
  bikes.append('trek')
  # Adding items to a specific index
  bikes.insert(<index_position>, <index_value>)
  # Get item from a specific index
  bikes.index(<index_position>)
  # Remove all occurances of a particular value
  bikes.remove(<value_to_be_removed>)

  # Making numerical Lists
  squares = []
  for x in range(1, 11):
      squares.append(x**2)

  # List Comprehensions
  squares = [x**2 for x in range(1,11)]

  # Slicing a list
  a = ['sam', 'bob', 'ada', 'bea']
  """
  a[start:end:step] # start through not past end, by step
  a[start:end]      # items start through end-1
  a[start:]         # items start through the rest of the array
  a[:end]           # items from the beginning through end-1
  a[:]              # copy of whole array
  """
  a[-1]    # last item in the array
  a[-2:]   # last two items in the array
  a[:-2]   # everything except the last two items

  a[::-1]    # all items in the array, reversed
  a[1::-1]   # the first two items, reversed
  a[:-3:-1]  # the last two items, reversed
  a[-3::-1]  # everything except the last two items, reversed
#+END_SRC

** tuples
#+BEGIN_SRC python
## Creating a tuple
dimensions = (1920, 1080)
#+END_SRC

** sys
#+BEGIN_SRC python
"""
--- Dynamic Objects ---
argv -- command line args
path -- module search path
path[0] -- script directory else ''
modules -- dictionary of loaded modules

stdin -- standard input file obj; used by input()
stdout -- standard output file obj; used by print()
stderr -- standard error obj; used for error messages

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception

--- Static Objects ---
builtin_module_names -- tuple of module names built into this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter.

--- functions ---
exit() -- exit the interpreter by raising SystemExit
"""
#+END_SRC


command line args for the following command:
#+BEGIN_SRC shell
python foo.py bar -c qux --h
#+END_SRC

#+BEGIN_SRC python
"""
sys.argv[0] => script_name => foo.py
sys.argv[1] => first_arg   => bar
sys.argv[2] => second_arg  => -c
sys.argv[3] => third_arg   => qux
sys.argv[4] => fourth_arg  => --h
"""
#+END_SRC

** os
#+BEGIN_SRC python
  """
  os.name    -> `posix` or `nt`
  os.curdir  -> .
  os.pardir  -> ..
  os.sep     -> '/' or '\'
  os.linesep -> '\r' or '\n' or '\r\n'
  os.devnull -> '/dev/null', etc
  """
#+END_SRC
** class special methods <lots of example needed>
#+BEGIN_SRC python
"""
__new__(cls)
__init__(self, args)
__del__(self)
__repr__(self)
__str__(self)
__cmp__(self, other)
__index__(self)
__hash__(self)
__getattr__(self, name)
__getattribute__(self, name)
__setattr__(self, name, attr)
__delattr__(self, name)
__call__(self, name, kwargs)
__lt__(self, other)
__le__(self, other)
__gt__(self, other)
__ge__(self, other)
__eq__(self, other)
__ne__(self, other)
__nonzero__(self)
"""
#+END_SRC

** modules and packages
[[./images/modules_and_packages/Python-packages-.gif]]
*** Modules
`<file-name>.py` contains definitions, functions, classes and statements
#+BEGIN_SRC python

  ##########################
  # Example: Creating module
  ##########################
  import math

  def circle_area(radius):
      return math.pi * (radius**2)

  def square_area(x):
      return x*x

  def rectangle_area(x, y):
      return x*y
  ##########################

  ##########################
  # Example: importing module
  ##########################
  import area
  print(area.circle_area(50)
  print(area.square_area(10)
  print(area.rectangle_area(10, 20)

  # you can use selective definitions
  from area import circle_area
  print(circle_area(50))

  # you can import everything by *
  from area import *
  print(circle_area(50))
  print(square_area(10))
  pritn(rectangle_area(10, 20))
  ##########################

#+END_SRC

*Executing modules as scripts* : `__name__` is set to `__main__` when the module is run as standalone program.
run script as stand-alone program
#+BEGIN_SRC python
  if __name__ == '__main__':
      print('Do Something')
#+END_SRC
*** packages 
dir of python modules
#+BEGIN_SRC python

####################
# package structure
####################
"""
geometry (package)
>>> __init__.py
>>> area.py (module)
>>> volume.py (module)
"""

####################
# package structure
####################
from geometry import area, volume
print(area.circle_area(5))
print(volume.cube_volume(12))

#+END_SRC

The Module to be recognized as package should have __path__ attribute
*** Locating Modules
*Module Search Path*: at the time of import; python interpreter searches for the module in the following 
1. pwd
2. each dir in the `PYTHONPATH`
3. default path - on unix `/usr/local/lib/python`

*More Examples*: [[./modules_and_packages.org][Modules and Packages]]

*** make a python package that can be installed via pip
[[./images/modules_and_packages/module_structure.png]]

1. create a module
#+BEGIN_SRC python
# file: duplicate.py
import collections
def get_duplicate(mylist):
    return [item for item, count in  collections.Counter(mylist).items() if count > 1]
#+END_SRC
2. make a python package
#+BEGIN_SRC python
file: __init__.py
#+END_SRC
3. make a distribution
create setup.py
setup.py contains *metadata* about your modules
#+BEGIN_SRC python
  from setuptools import setup, find_packages

  setup(
      name='detect-duplicate', # write your own package name here
      packages=find_packages(),
      version='1.1.1',
      description='Detect duplicate elements in a list',
      author='Alamin Khan',
      author_email="alamin@khan.com",
      url='https://github.com/alaminkhan/detect-duplicate',
      keywords=['detect duplicate', 'find duplicate', 'list'], # arbitrary keywords
      license='MIT',
      classifiers=[],
      install_requirs=[]
  )
#+END_SRC

goto the first-pakcage folder
#+BEGIN_SRC shell
python3 setup.py sdist
#+END_SRC

install your distribution into your local copy of python
#+BEGIN_SRC shell
python3 setup.py install
#+END_SRC

4. Registering with pypi
5. upload your code

#+BEGIN_SRC shell
python3 setup.py register
#+END_SRC

finally upload the dist
#+BEGIN_SRC shell
python3 setup.py sdist upload
#+END_SRC

after that just install

#+BEGIN_SRC shell
pip install <yourpackagename>
#+END_SRC

** applications - frequent libs ref
*** web and internet
1. requests - an http client library
2. beautifulsoup - an html parser
3. feedparser - for parsing rss/atom feeds
4. paramiko - implementing the ssh2 protocol
5. twisted python - async network prog
*** gui
1. tk - builtins
2. wxWidgets
3. kivy
4. qt
5. gtk+
6. microsoft foundation classes through the win32 extensions
7. delphi
*** scientific and numeric
1. scipy - collection of packages for mathematics science and engineering.
2. pandas - data analysis and modeling lib
3. ipython - powerful shell for easy editing and recording of work sessions. supports visualizations and parallel computing.
4. software carpentry course - teaches basic skills for scientific computing and running bootcamps. open-access teaching materials.
5. numpy - complex numerical calculations

*** software dev
1. scons - build-control
2. buildbot, apache gump - automated and continuous compilation and testing
3. roundup, trac - project management and bug-tracking
4. roster of IDE
*** business app
- tryton - three-tier, high-level general-purpose application platform
- odoo - management software
*** network
- twisted python - async network programming
- socket interface
- ansible
- netmiko
- napalm
- pyeapi
- juno pyEZ
- pySNM
- paramiko SSH
*** game
pygame, pykyra

*** big data
- matplotlib
- seaborn
- pandas
- scikit-learn
- scipy
- graphlab create
- ipython
- bokeh
- agate
- pyspark
- dask
** tools
- dis module ⇒ compiles a script, disassembles the bytecode, and prints the output to the STDOUT.
- pdb module ⇒ standard python debugger
- tbnanny module ⇒ checks weird combinations of tabs and spaces.

* QUICK REFERENCE
** Reading and writing files
1. [[./csv.org][csv]]
2. xml
3. xlrd
4. python-docx
5. zipfile
6. json
7. os
** Data visualizations
*** matplotlib
*** bokeh
*** pillow
** Data Analysis
*** pandas
*** numpy
*** scipy
*** scikit-learn
** Interacting with the web
*** urllib
*** beautiful soup
*** bottle
* Notes
- *popular implementation* - CPYTHON
- Compiles a python program into `Intermediate BYTECODE`.
* Contributing
Please read [[./CONTRIBUTING.md][CONTRIBUTING.md]] for details on our code of conduct, and the process for submitting pull requests to us.

* Versioning
We use [[http://semver.org/][SemVer]] for versioning. For the versions available, see the tags on this repository.

* Authors
Billie Thompson - Initial work - PurpleBooth
See also the list of contributors who participated in this project.

* License
This project is licensed under the MIT License - see the [[./LICENSE][LICENSE]] file for details

* Acknowledgments
Hat tip to anyone whose code was used
Inspiration
etc
