#+TITLE: My Awesome Python Handbook
#+AUTHOR: Muhammad Alamin Khan
#+EMAIL: alamin.ineedahelp@gmail.com
#+STARTUP: overview indent inlineimages hideblocks
#+DESCRIPTION: Quick Reference for this ever-forgetting mind.
#+OPTIONS: toc:2          
Notes that I tend to forget all the time and search on the internet

* CHEATSHEET
** architecture
[[./images/architecture/001.jpg]]
- *Parser* - source code ⇒ abstract syntax tree [AST].
- *compiler* - AST ⇒ Python Byte Code.
- *interpreter* - execute line by line
*More* - [[./architecture.org][architecture.org]]
** components
functions ⇒ classes ⇒ modules ⇒ packages
** file extensions
- py ⇒ The normal extension for a Python source file
- pyc ⇒ The compiled bytecode
- pyd ⇒ A Windows DLL file
- pyo ⇒ A file created with optimizations
- pyw ⇒ Python script for Windows
- pyz ⇒ Python script archive
** pros and cons
*** pros
- extensive libs
- embeddable
- iot
- readable
- free and open source
- extensible
- improved productivity
- simple and easy
- oop
- portable
*** cons
- speed limitations
- weak in mobile computing and browsers
- design restrictions
- underdeveloped Database Access Layers
- simple
** rules
#+BEGIN_SRC python
"""
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
"""
#+END_SRC

** variable types
| Variable Type | Description                            | Casting | Examples                |
|---------------+----------------------------------------+---------+-------------------------|
| int           | whole number                           | int()   | 5, -11, 0               |
| float         | float number                           | float() | 9.57, -0.256, 1.0       |
| string        | ordered, immutable character container | str()   | "this is a string"      |
| bool          | bolean                                 | bool()  | true, false             |
| list          | ordered, mutable container             | list()  | [1, 2.0, "hi"]          |
| dictionary    | unordered, mutable, associative array  | dict()  | {"k1": "v1", "k2":"v2"  |
| tuple         | ordered, immutable                     | tuple() | (4, 9), ("word1", "w2") |
| set           | immutable, ordered                     | set()   | {1, 2, 3, "hello"}      |
|---------------+----------------------------------------+---------+-------------------------|
*** Numbers
- Real Numbers
- Complex Numbers
#+BEGIN_SRC python
a = 2 + 3j
#+END_SRC
- binary, octal, hexadecimal
#+BEGIN_SRC python
'''
binary  => 0b or 0B
octal   => 0o or 0O
hexadec => 0x or 0X
'''
#+END_SRC
- decimal module
- fractions module
- math module
** variable scope
*** Different scopes:
[[https://data-flair.training/blogs/wp-content/uploads/Scopes-01.jpg]]
- local
#+BEGIN_SRC python
  >>> a=0
  >>> def func():
        print(a)
        a=1
        print(a)            
  >>> func()
  Traceback (most recent call last):
  File "<pyshell#79>", line 1, in <module>
  func()
  File "<pyshell#78>", line 2, in func
  print(a)
  UnboundLocalError: Local Variable 'a' referenced before assignment.
#+END_SRC
- enclosing
#+BEGIN_SRC python
  def red():
      a = 1
    
      def blue():
          b = 2
          print(a)
          print(b)

      blue()
      print(a)

  red()

"""
1
2
1
"""
#+END_SRC
- nonlocal <keyword>
#+BEGIN_SRC python
  # without nonlocal
  x = 0
  def outer():
      x = 1
      def inner():
          x = 2
          print("inner:", x)

      inner()
      print("outer:", x)

  outer()
  print("global:", x)

  # inner: 2
  # outer: 1
  # global: 0
#+END_SRC
#+BEGIN_SRC python
"""
To this, using nonlocal, where inner()'s x is now also outer()'s x:
"""
x = 0
def outer():
    x = 1
    def inner():
        nonlocal x
        x = 2
        print("inner:", x)

    inner()
    print("outer:", x)

outer()
print("global:", x)

# inner: 2
# outer: 2
# global: 0
#+END_SRC
#+BEGIN_SRC python
"""
If we were to use global, it would bind x to the properly "global" value:
"""
x = 0
def outer():
    x = 1
    def inner():
        global x
        x = 2
        print("inner:", x)

    inner()
    print("outer:", x)

outer()
print("global:", x)

# inner: 2
# outer: 1
# global: 2
#+END_SRC
- global
#+BEGIN_SRC python
  a = 1
  def counter():
      global a
      a = 2
      print(a)
  counter()
  """
  a becomes 2 both inside and outside
  """
#+END_SRC
- built-in
#+BEGIN_SRC python
"""
we never need to import any modules to access built-ins like print(), id()
"""
#+END_SRC
** operators
#+BEGIN_SRC python
5 +  5   # + => addition
6 -  2   # - => subtraction
1 *  2   # * => multiplication
5 /  2   # / => division with floating point ## output:: 2.5
5 // 2   # // => division flooring the float value ## output :: 2
2 ** 3   # exponent
5 %  2   # modulus
5 >  2   # greater than op
5 <  2   # less than op
5 >= 2   # greater than equal
5 <= 2   # lesser than equal
5 == 5   # returns true if equal else false
5 is 5   # returns true if equal else false
10 != 5  # returns true if not equal
10 is not 5 # returns true if not equal
1 in [3, 4, 5, 6] # returns true if 1 is in the collection
#+END_SRC

bitwise operators
#+BEGIN_SRC python
>>> 2&3
2 # 10 & 11 => 10
>>> 2|3
3 # 10 | 11 => 11
>>> 2^3
1  # 10 ^ 11 => 01
>>> ~-3
2  # -(-3) - 1 => 2
>>> 2<<2
8 # ((2 * 2) * 2)
>>> 3>>2
0 # (3//2)//2
>>> 3>>1
1 # 3//2

#+END_SRC
** strings
*** create a string
#+BEGIN_SRC python
>>> type('Hello World')
<class 'str'>
#+END_SRC

python doesn't have the char data-type
#+BEGIN_SRC python
a='Hello"
# outputs
# SyntaxError: EOL while scanning string literal
#+END_SRC

a string is immutable; it can't be changed
#+BEGIN_SRC python
>>> a="Dogs"
>>> a[0]="H"
Traceback (most recent call last):
File "<pyshell#22>", line 1, in <module>
a[0]="H"

"""
TypeError: 'str' object doesn't support item assignment
"""
#+END_SRC

*** string slicing
#+BEGIN_SRC python
a = 'Hello There'
# displaying a single character
a[1]

# slicing a string
"""
a[start:end:step] # start through not past end, by step
a[start:end]      # items start through end-1
a[start:]         # items start through the rest of the array
a[:end]           # items from the beginning through end-1
a[:]              # copy of whole array
"""
#+END_SRC
*** string concatenation
#+BEGIN_SRC python
a = 'Do you see this,'
b = '$$'
a + b # => 'Do you see this, $$
2 * a # => Do you see this,Do you see this,
a * 2 # => Do you see this,Do you see this,

>>> '10'+10
Traceback (most recent call last):
File "<pyshell#49>", line 1, in <module>
#+END_SRC
*** string formatters
#+BEGIN_SRC python
"""
f-strings
"""
name='John D. Rockerfeller'
print(f"Happy birthday, {name} Sir")
#+END_SRC

#+BEGIN_SRC python
"""
format() method
"""
a="cats"
print("I love {0}".format(a))
print("I love {0}".format(a="Dogs"))

"""
The variables don’t have to defined before the print statement
"""
print("I love {b}".format(b='ferrets'))

"""
% operator- The % operator goes where the variables go in a string. 
%s is for string. What follows the string is the operator and variables in parentheses/in a tuple.
%d -> int
%f -> float
"""
print("I love %s and %s" %(a,b))
#+END_SRC

*** string functions
#+BEGIN_SRC python
>>> a='book'
>>> len(a)
4
>>> len(a[2:])
2
>>> str(2+3j)
'2+3j'
>>> str(['red', 'green', 'blue'])
"['red', 'green', 'blue']"
>>> a='Book'
>>> a.lower()
'book'
>>> a.upper()
'BOOK'
>>> a=' book '
>>> a.strip()
'book'
>>> a = '777'
>>> a.isdigit()
True
>>> a='77a'
>>> a.isdigit()
False
>>> a='abc'
>>> a.isalpha()
True
>>> a='ab3'
>>> a.isalpha()
False
>>> a = '    '
>>> a.isspace()
True
>>> a=' \'  '
>>> a.isspace()
False
>>> a = 'university'
>>> a.startswith('un')
True
>>> a = 'university'
>>> a.endswith('ty')
True
>>> 'homeowner'.find('meow')
2
>>> 'homeowner'.find('ty')
-1 # if string is not found then return -1
>>> 'banana'.replace('na', 'ha')
'bahaha'
>>> 'No. okay. why?'.split('.')
['No', ' okay', ' why?']
>>> "*".join(['red','green','blue'])
'red*green*blue'
#+END_SRC
*** string operations
#+BEGIN_SRC python
# comparison
>>> 'hey' < 'hi'
True # lexicographically
>>> a='check'
>>> a=='check'
True
>>> 'yes'!='no'
True

# arithmetic
>>> 'ba'+'na'*2
'banana'

# membership
>>> 'na' in 'banana'
True
>>> 'less' not in 'helpless'
False

# identity
# python's identity operators 'is' and 'is not' can be used on strings.
>>> "Hey" is "Hi"
False
>>> "Yo" is not "yo"
True

# logical
# an empty string has a boolean value of false.
>>> '' and '1'
""
>>> '1' and ''
""
>>> "1" or ""
"1"
>>> "" or "1"
"1"
>>> not('1')
False
>>> not('')
True
#+END_SRC
** lists
#+BEGIN_SRC python
  # create a list
  bikes = ['trek', 
	   'redline',
	   'giant']

  # list index structure
  """
   +---+---+---+---+---+---+
   | P | y | t | h | o | n |
   +---+---+---+---+---+---+
     0   1   2   3   4   5   
    -6  -5  -4  -3  -2  -1
  """
  # first item
  bikes[0]
  # last item
  bikes[-1]

  # looping through a list
  for bike in bikes:
      print(bike)


  bikes = []
  # Adding items to a list at the end
  bikes.append('trek')
  # Adding items to a specific index
  bikes.insert(<index_position>, <index_value>)
  # Get item from a specific index
  bikes.index(<index_position>)
  # Remove all occurances of a particular value
  bikes.remove(<value_to_be_removed>)

  # Making numerical Lists
  squares = []
  for x in range(1, 11):
      squares.append(x**2)

  # List Comprehensions
  squares = [x**2 for x in range(1,11)]

  # Slicing a list
  a = ['sam', 'bob', 'ada', 'bea']
  """
  a[start:end:step] # start through not past end, by step
  a[start:end]      # items start through end-1
  a[start:]         # items start through the rest of the array
  a[:end]           # items from the beginning through end-1
  a[:]              # copy of whole array
  """
  a[-1]    # last item in the array
  a[-2:]   # last two items in the array
  a[:-2]   # everything except the last two items

  a[::-1]    # all items in the array, reversed
  a[1::-1]   # the first two items, reversed
  a[:-3:-1]  # the last two items, reversed
  a[-3::-1]  # everything except the last two items, reversed
#+END_SRC

** tuples
#+BEGIN_SRC python
## Creating a tuple
dimensions = (1920, 1080)
#+END_SRC

** sys
#+BEGIN_SRC python
"""
--- Dynamic Objects ---
argv -- command line args
path -- module search path
path[0] -- script directory else ''
modules -- dictionary of loaded modules

stdin -- standard input file obj; used by input()
stdout -- standard output file obj; used by print()
stderr -- standard error obj; used for error messages

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception

--- Static Objects ---
builtin_module_names -- tuple of module names built into this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter.

--- functions ---
exit() -- exit the interpreter by raising SystemExit
"""
#+END_SRC


command line args for the following command:
#+BEGIN_SRC shell
python foo.py bar -c qux --h
#+END_SRC

#+BEGIN_SRC python
"""
sys.argv[0] => script_name => foo.py
sys.argv[1] => first_arg   => bar
sys.argv[2] => second_arg  => -c
sys.argv[3] => third_arg   => qux
sys.argv[4] => fourth_arg  => --h
"""
#+END_SRC

** os
#+BEGIN_SRC python
  """
  os.name    -> `posix` or `nt`
  os.curdir  -> .
  os.pardir  -> ..
  os.sep     -> '/' or '\'
  os.linesep -> '\r' or '\n' or '\r\n'
  os.devnull -> '/dev/null', etc
  """
#+END_SRC
** class special methods <lots of example needed>
#+BEGIN_SRC python
"""
__new__(cls)
__init__(self, args)
__del__(self)
__repr__(self)
__str__(self)
__cmp__(self, other)
__index__(self)
__hash__(self)
__getattr__(self, name)
__getattribute__(self, name)
__setattr__(self, name, attr)
__delattr__(self, name)
__call__(self, name, kwargs)
__lt__(self, other)
__le__(self, other)
__gt__(self, other)
__ge__(self, other)
__eq__(self, other)
__ne__(self, other)
__nonzero__(self)
"""
#+END_SRC

** modules and packages
[[./images/modules_and_packages/Python-packages-.gif]]
*** Modules
`<file-name>.py` contains definitions, functions, classes and statements
#+BEGIN_SRC python

  ##########################
  # Example: Creating module
  ##########################
  import math

  def circle_area(radius):
      return math.pi * (radius**2)

  def square_area(x):
      return x*x

  def rectangle_area(x, y):
      return x*y
  ##########################

  ##########################
  # Example: importing module
  ##########################
  import area
  print(area.circle_area(50)
  print(area.square_area(10)
  print(area.rectangle_area(10, 20)

  # you can use selective definitions
  from area import circle_area
  print(circle_area(50))

  # you can import everything by *
  from area import *
  print(circle_area(50))
  print(square_area(10))
  pritn(rectangle_area(10, 20))
  ##########################

#+END_SRC

*Executing modules as scripts* : `__name__` is set to `__main__` when the module is run as standalone program.
run script as stand-alone program
#+BEGIN_SRC python
  if __name__ == '__main__':
      print('Do Something')
#+END_SRC
*** packages 
dir of python modules
#+BEGIN_SRC python

####################
# package structure
####################
"""
geometry (package)
>>> __init__.py
>>> area.py (module)
>>> volume.py (module)
"""

####################
# package structure
####################
from geometry import area, volume
print(area.circle_area(5))
print(volume.cube_volume(12))

#+END_SRC

The Module to be recognized as package should have __path__ attribute
*** Locating Modules
*Module Search Path*: at the time of import; python interpreter searches for the module in the following 
1. pwd
2. each dir in the `PYTHONPATH`
3. default path - on unix `/usr/local/lib/python`

*More Examples*: [[./modules_and_packages.org][Modules and Packages]]

*** make a python package that can be installed via pip
[[./images/modules_and_packages/module_structure.png]]

1. create a module
#+BEGIN_SRC python
# file: duplicate.py
import collections
def get_duplicate(mylist):
    return [item for item, count in  collections.Counter(mylist).items() if count > 1]
#+END_SRC
2. make a python package
#+BEGIN_SRC python
file: __init__.py
#+END_SRC
3. make a distribution
create setup.py
setup.py contains *metadata* about your modules
#+BEGIN_SRC python
  from setuptools import setup, find_packages

  setup(
      name='detect-duplicate', # write your own package name here
      packages=find_packages(),
      version='1.1.1',
      description='Detect duplicate elements in a list',
      author='Alamin Khan',
      author_email="alamin@khan.com",
      url='https://github.com/alaminkhan/detect-duplicate',
      keywords=['detect duplicate', 'find duplicate', 'list'], # arbitrary keywords
      license='MIT',
      classifiers=[],
      install_requirs=[]
  )
#+END_SRC

goto the first-pakcage folder
#+BEGIN_SRC shell
python3 setup.py sdist
#+END_SRC

install your distribution into your local copy of python
#+BEGIN_SRC shell
python3 setup.py install
#+END_SRC

4. Registering with pypi
5. upload your code

#+BEGIN_SRC shell
python3 setup.py register
#+END_SRC

finally upload the dist
#+BEGIN_SRC shell
python3 setup.py sdist upload
#+END_SRC

after that just install

#+BEGIN_SRC shell
pip install <yourpackagename>
#+END_SRC

** applications - frequent libs ref
*** web and internet
1. requests - an http client library
2. beautifulsoup - an html parser
3. feedparser - for parsing rss/atom feeds
4. paramiko - implementing the ssh2 protocol
5. twisted python - async network prog
*** gui
1. tk - builtins
2. wxWidgets
3. kivy
4. qt
5. gtk+
6. microsoft foundation classes through the win32 extensions
7. delphi
*** scientific and numeric
1. scipy - collection of packages for mathematics science and engineering.
2. pandas - data analysis and modeling lib
3. ipython - powerful shell for easy editing and recording of work sessions. supports visualizations and parallel computing.
4. software carpentry course - teaches basic skills for scientific computing and running bootcamps. open-access teaching materials.
5. numpy - complex numerical calculations

*** software dev
1. scons - build-control
2. buildbot, apache gump - automated and continuous compilation and testing
3. roundup, trac - project management and bug-tracking
4. roster of IDE
*** business app
- tryton - three-tier, high-level general-purpose application platform
- odoo - management software
*** network
- twisted python - async network programming
- socket interface
- ansible
- netmiko
- napalm
- pyeapi
- juno pyEZ
- pySNM
- paramiko SSH
*** game
pygame, pykyra

*** big data
- matplotlib
- seaborn
- pandas
- scikit-learn
- scipy
- graphlab create
- ipython
- bokeh
- agate
- pyspark
- dask
** tools
- dis module ⇒ compiles a script, disassembles the bytecode, and prints the output to the STDOUT.
- tbnanny module ⇒ checks weird combinations of tabs and spaces.
*** debugging
pdb module ⇒ python interactive debugger
**** printing a variables value
#+BEGIN_SRC python
import pdb; pdb.set_trace()
#+END_SRC
in `python 3.7` there's `breakpoint()` built-in
#+BEGIN_SRC python
breakpoint()
"""
it allows you to control debugging behavior via it's API and use of the environment variable PYTHONBREAKPOINT.
setting PYTHONBREAKPOINT=0 in your environment will completely disable breakpoint(), thus disabling debugging.
"""
#+END_SRC

#+BEGIN_SRC python
#!/usr/bin/env python3

filename = __file__
import pdb; pdb.set_trace()
print(f'path = {filename}')
#+END_SRC


#+BEGIN_SRC shell
$ ./example1.py 
> /code/example1.py(5)<module>()
-> print(f'path = {filename}')
(Pdb) 
#+END_SRC

#+BEGIN_SRC shell
(Pdb) p filename
'./example1.py'
(Pdb)
#+END_SRC

- `>` starts the 1st line and tells you which source file you're in. after the filename, there is `current line number(5)`. Next the name of the function. Since we're not paused inside a function and at module level, we see `<module>()`.
- `->` starts the 2nd line and is the current source line where python is paused. The line hasn't been executed yet.
- `(Pdb)` is pdb's prompt. It's waiting for a command.
#+BEGIN_SRC shell
(Pdb) q # Quits debugging and exit.
#+END_SRC

**** printing expressions
#+BEGIN_SRC python
#!/usr/bin/env python3

import os


def get_path(filename):
    """Return file's path or empty string if no path."""
    head, tail = os.path.split(filename)
    import pdb; pdb.set_trace()
    return head


filename = __file__
print(f'path = {get_path(filename)}')
#+END_SRC
#+BEGIN_SRC shell
$ ./example2.py 
> /code/example2.py(10)get_path()
-> return head
(Pdb) 
#+END_SRC
#+BEGIN_SRC shell
(Pdb) ll
  6     def get_path(filename):
  7         """Return file's path or empty string if no path."""
  8         head, tail = os.path.split(filename)
  9         import pdb; pdb.set_trace()
 10  ->     return head
(Pdb) p filename
'./example2.py'
(Pdb) p head, tail
('.', 'example2.py')
(Pdb) p 'filename: ' + filename
'filename: ./example2.py'
(Pdb) p get_path
<function get_path at 0x100760e18>
(Pdb) p getattr(get_path, '__doc__')
"Return file's path or empty string if no path."
(Pdb) p [os.path.split(p)[1] for p in os.path.sys.path]
['pdb-basics', 'python36.zip', 'python3.6', 'lib-dynload', 'site-packages']
(Pdb) 
#+END_SRC
use `pp` for `pretty print`.
**** stepping through code
| Command | Description |
|---------+-------------|
| n(next) | step over   |
| s(step) | step in     |

- *n (next)* : Continue-execution until the next line in the current function is reached or it returns.
#+BEGIN_EXAMPLE
Use n (next) to continue execution until the next line and stay within the current function, i.e. not stop in a foreign function if one is called. Think of next as “staying local” or “step over”.
#+END_EXAMPLE
- *s (step)* : Execute the current line and stop at the first possible occasion (either in a function that is called or in the current function).
#+BEGIN_EXAMPLE
Use s (step) to execute the current line and stop in a foreign function if one is called. Think of step as “step into”. If execution is stopped in another function, s will print --Call--.
#+END_EXAMPLE

#+BEGIN_SRC python
#!/usr/bin/env python3

import os


def get_path(filename):
    """Return file's path or empty string if no path."""
    head, tail = os.path.split(filename)
    return head


filename = __file__
import pdb; pdb.set_trace()
filename_path = get_path(filename)
print(f'path = {filename_path}')
#+END_SRC

#+BEGIN_SRC shell
$ ./example3.py 
> /code/example3.py(14)<module>()
-> filename_path = get_path(filename)
(Pdb) n
> /code/example3.py(15)<module>()
-> print(f'path = {filename_path}')
(Pdb) 
#+END_SRC
With n (next), we stopped on line 15, the next line. We “stayed local” in <module>() and “stepped over” the call to get_path(). The function is <module>() since we’re currently at module level and not paused inside another function.

Let's try `s`:
#+BEGIN_SRC shell
$ ./example3.py 
> /code/example3.py(14)<module>()
-> filename_path = get_path(filename)
(Pdb) s
--Call--
> /code/example3.py(6)get_path()
-> def get_path(filename):
(Pdb) 
#+END_SRC
With s (step), we stopped on line 6 in the function get_path() since it was called on line 14. Notice the line --Call-- after the s command.

Press `Enter` for previous command in `pdb`.
#+BEGIN_SRC shell
$ ./example3.py 
> /code/example3.py(14)<module>()
-> filename_path = get_path(filename)
(Pdb) s
--Call--
> /code/example3.py(6)get_path()
-> def get_path(filename):
(Pdb) n
> /code/example3.py(8)get_path()
-> head, tail = os.path.split(filename)
(Pdb) 
> /code/example3.py(9)get_path()
-> return head
(Pdb) 
--Return--
> /code/example3.py(9)get_path()->'.'
-> return head
(Pdb) 
> /code/example3.py(15)<module>()
-> print(f'path = {filename_path}')
(Pdb) 
path = .
--Return--
> /code/example3.py(15)<module>()->None
-> print(f'path = {filename_path}')
(Pdb) 
#+END_SRC

Note the lines `--Call--` and `--Return--`. This is pdb letting you know why execution was stopped. n (next) and s (step) will stop before a function returns. That’s why you see the `--Return--` lines above.

Also note ->'.' at the end of the line after the first --Return-- above:
#+BEGIN_SRC shell
--Return--
> /code/example3.py(9)get_path()->'.'
-> return head
(Pdb) 
#+END_SRC

** 3.7 new features
- PEP 539, new C API for thread-local storage
- PEP 545, python documentation translations
- PEP 552, Deterministic pyc files
- PEP 557, Data Classes
- PEP 560, Core Support for typing module and generic types
- PEP 562, Customization of access to module attributes
- PEP 563, Postponed evaluation of annotations
- PEP 564, Time functions with nanosecond resolution
- PEP 565, Improved `DeprecationWarning` handling
- PEP 567, Context Variables
* QUICK REFERENCE
** Reading and writing files
1. [[./csv.org][csv]]
2. xml
3. xlrd
4. python-docx
5. zipfile
6. json
7. os
** Data visualizations
*** matplotlib
*** bokeh
*** pillow
** Data Analysis
*** pandas
*** numpy
*** scipy
*** scikit-learn
** Interacting with the web
*** urllib
*** beautiful soup
*** bottle
* Notes
- *popular implementation* - CPYTHON
- Compiles a python program into `Intermediate BYTECODE`.
* Contributing
Please read [[./CONTRIBUTING.md][CONTRIBUTING.md]] for details on our code of conduct, and the process for submitting pull requests to us.

* Versioning
We use [[http://semver.org/][SemVer]] for versioning. For the versions available, see the tags on this repository.

* Authors
Billie Thompson - Initial work - PurpleBooth
See also the list of contributors who participated in this project.

* License
This project is licensed under the MIT License - see the [[./LICENSE][LICENSE]] file for details
* Acknowledgments
Hat tip to anyone whose code was used
Inspiration
etc
